/**
 * Truncate the tree to a certain number of characters.
 *
 * @template {Node} Tree
 *   Type of tree.
 * @param {Tree} tree
 *   Tree to truncate.
 * @param {Options | null | undefined} [options]
 *   Configuration (optional).
 * @returns {Tree}
 *   A shallow copy of `tree`, truncated.
 */
export function truncate<Tree extends Node>(
  tree: Tree,
  options?: Options | null | undefined
): Tree
export type Root = import('hast').Root
export type Content = import('hast').Content
export type Text = import('hast').Text
export type Node = Root | Content
/**
 * Configuration.
 */
export type Options = {
  /**
   * Number of characters to truncate to.
   */
  size?: number | null | undefined
  /**
   * Value to use at truncation point.
   */
  ellipsis?: string | null | undefined
  /**
   * How far to walk back.
   * The algorithm attempts to break right after a word rather than the exact
   * `size`.
   * Take for example the `|`, which is the actual break defined by `size`, and
   * the `…` is the location where the ellipsis is placed: `This… an|d that`.
   * Breaking at `|` would at best look bad but could likely result in things
   * such as `ass…` for `assignment` — which is not ideal.
   * `maxCharacterStrip` defines how far back the algorithm will walk to find
   * a pretty word break.
   * This prevents a potential slow operation on larger `size`s without any
   * whitespace.
   * If `maxCharacterStrip` characters are walked back and no nice break point
   * is found, the bad break point is used.
   * Set `maxCharacterStrip: 0` to not find a nice break.
   */
  maxCharacterStrip?: number | null | undefined
  /**
   * Nodes to exclude from the resulting tree.
   * These are not counted towards `size`.
   */
  ignore?: Array<Content> | null | undefined
}
