{"version":3,"file":"utils.js","names":["filterHeadProps","input","location","pathname","params","data","serverData","pageContext","headExportValidator","head","Error","warnOnce","_","process","env","NODE_ENV","warnings","Set","msg","has","console","warn","add","warnForInvalidTag","tagName","warning","createWarningForInvalidTag","VALID_NODE_NAMES","join","isEqualNode","oldTag","newTag","HTMLElement","nonce","getAttribute","cloneTag","cloneNode","setAttribute","diffNodes","oldNodes","newNodes","onStale","onNew","existingHeadElement","indexInNewNodes","findIndex","e","splice","newNode","getValidHeadNodesAndAttributes","rootNode","htmlAndBodyAttributes","html","body","seenIds","Map","validHeadNodes","node","childNodes","nodeName","toLowerCase","id","attributes","value","isElementType","isValidNodeName","attribute","isStyleAttribute","name","style","clonedNode","massageScript","push","set","length","indexOfPreviouslyInsertedNode","get","parentNode","removeChild","script","document","createElement","attr","innerHTML","includes","nodeType","removePrevHeadElements","prevHeadNodes","querySelectorAll","applyHtmlAndBodyAttributes","htmlElement","querySelector","Object","entries","forEach","attributeName","attributeValue","bodyElement","removeHtmlAndBodyAttributes","htmlAndBodyattributeList","removeAttribute"],"sources":["../../head/utils.js"],"sourcesContent":["import { VALID_NODE_NAMES } from \"./constants\"\n\n/**\n * Filter the props coming from a page down to just the ones that are relevant for head.\n * This e.g. filters out properties that are undefined during SSR.\n */\nexport function filterHeadProps(input) {\n  return {\n    location: {\n      pathname: input.location.pathname,\n    },\n    params: input.params,\n    data: input.data || {},\n    serverData: input.serverData,\n    pageContext: input.pageContext,\n  }\n}\n\n/**\n * Throw error if Head export is not a valid function\n */\nexport function headExportValidator(head) {\n  if (typeof head !== `function`)\n    throw new Error(\n      `Expected \"Head\" export to be a function got \"${typeof head}\".`\n    )\n}\n\n/**\n * Warn once for same messsage\n */\nlet warnOnce = _ => {}\nif (process.env.NODE_ENV !== `production`) {\n  const warnings = new Set()\n  warnOnce = msg => {\n    if (!warnings.has(msg)) {\n      console.warn(msg)\n    }\n    warnings.add(msg)\n  }\n}\n\n/**\n * Warn for invalid tags in Head which may have been directly added or introduced by `wrapRootElement`\n * @param {string} tagName\n */\nexport function warnForInvalidTag(tagName) {\n  if (process.env.NODE_ENV !== `production`) {\n    const warning = createWarningForInvalidTag(tagName)\n    warnOnce(warning)\n  }\n}\n\nfunction createWarningForInvalidTag(tagName) {\n  return `<${tagName}> is not a valid head element. Please use one of the following: ${VALID_NODE_NAMES.join(\n    `, `\n  )}.\\n\\nAlso make sure that wrapRootElement in gatsby-ssr/gatsby-browser doesn't contain UI elements: https://gatsby.dev/invalid-head-elements`\n}\n\n/**\n * When a `nonce` is present on an element, browsers such as Chrome and Firefox strip it out of the\n * actual HTML attributes for security reasons *when the element is added to the document*. Thus,\n * given two equivalent elements that have nonces, `Element,isEqualNode()` will return false if one\n * of those elements gets added to the document. Although the `element.nonce` property will be the\n * same for both elements, the one that was added to the document will return an empty string for\n * its nonce HTML attribute value.\n *\n * This custom `isEqualNode()` function therefore removes the nonce value from the `newTag` before\n * comparing it to `oldTag`, restoring it afterwards.\n *\n * For more information, see:\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1211471#c12\n */\nexport function isEqualNode(oldTag, newTag) {\n  if (oldTag instanceof HTMLElement && newTag instanceof HTMLElement) {\n    const nonce = newTag.getAttribute(`nonce`)\n    // Only strip the nonce if `oldTag` has had it stripped. An element's nonce attribute will not\n    // be stripped if there is no content security policy response header that includes a nonce.\n    if (nonce && !oldTag.getAttribute(`nonce`)) {\n      const cloneTag = newTag.cloneNode(true)\n      cloneTag.setAttribute(`nonce`, ``)\n      cloneTag.nonce = nonce\n      return nonce === oldTag.nonce && oldTag.isEqualNode(cloneTag)\n    }\n  }\n\n  return oldTag.isEqualNode(newTag)\n}\n\nexport function diffNodes({ oldNodes, newNodes, onStale, onNew }) {\n  for (const existingHeadElement of oldNodes) {\n    const indexInNewNodes = newNodes.findIndex(e =>\n      isEqualNode(e, existingHeadElement)\n    )\n\n    if (indexInNewNodes === -1) {\n      onStale(existingHeadElement)\n    } else {\n      // this node is re-created as-is, so we keep old node, and remove it from list of new nodes (as we handled it already here)\n      newNodes.splice(indexInNewNodes, 1)\n    }\n  }\n\n  // remaing new nodes didn't have matching old node, so need to be added\n  for (const newNode of newNodes) {\n    onNew(newNode)\n  }\n}\n\nexport function getValidHeadNodesAndAttributes(\n  rootNode,\n  htmlAndBodyAttributes = {\n    html: {},\n    body: {},\n  }\n) {\n  const seenIds = new Map()\n  const validHeadNodes = []\n\n  // Filter out non-element nodes before looping since we don't care about them\n  for (const node of rootNode.childNodes) {\n    const nodeName = node.nodeName.toLowerCase()\n    const id = node.attributes?.id?.value\n\n    if (!isElementType(node)) continue\n\n    if (isValidNodeName(nodeName)) {\n      // <html> and <body> tags are treated differently, in that we don't render them, we only extract the attributes and apply them separetely\n      if (nodeName === `html` || nodeName === `body`) {\n        for (const attribute of node.attributes) {\n          const isStyleAttribute = attribute.name === `style`\n\n          // Merge attributes for same nodeName from previous loop iteration\n          htmlAndBodyAttributes[nodeName] = {\n            ...htmlAndBodyAttributes[nodeName],\n          }\n\n          if (!isStyleAttribute) {\n            htmlAndBodyAttributes[nodeName][attribute.name] = attribute.value\n          }\n\n          // If there is already a style attribute, we need to merge them as otherwise the last one will \"win\"\n          if (isStyleAttribute) {\n            htmlAndBodyAttributes[nodeName].style = `${\n              htmlAndBodyAttributes[nodeName]?.style\n                ? htmlAndBodyAttributes[nodeName].style\n                : ``\n            }${attribute.value} `\n          }\n        }\n      } else {\n        let clonedNode = node.cloneNode(true)\n        clonedNode.setAttribute(`data-gatsby-head`, true)\n\n        // // This is hack to make script tags work\n        if (clonedNode.nodeName.toLowerCase() === `script`) {\n          clonedNode = massageScript(clonedNode)\n        }\n        // Duplicate ids are not allowed in the head, so we need to dedupe them\n        if (id) {\n          if (!seenIds.has(id)) {\n            validHeadNodes.push(clonedNode)\n            seenIds.set(id, validHeadNodes.length - 1)\n          } else {\n            const indexOfPreviouslyInsertedNode = seenIds.get(id)\n            validHeadNodes[\n              indexOfPreviouslyInsertedNode\n            ].parentNode?.removeChild(\n              validHeadNodes[indexOfPreviouslyInsertedNode]\n            )\n            validHeadNodes[indexOfPreviouslyInsertedNode] = clonedNode\n          }\n        } else {\n          validHeadNodes.push(clonedNode)\n        }\n      }\n    } else {\n      warnForInvalidTag(nodeName)\n    }\n\n    if (node.childNodes.length) {\n      validHeadNodes.push(\n        ...getValidHeadNodesAndAttributes(node, htmlAndBodyAttributes)\n          .validHeadNodes\n      )\n    }\n  }\n\n  return { validHeadNodes, htmlAndBodyAttributes }\n}\n\nfunction massageScript(node) {\n  const script = document.createElement(`script`)\n  for (const attr of node.attributes) {\n    script.setAttribute(attr.name, attr.value)\n  }\n  script.innerHTML = node.innerHTML\n\n  return script\n}\n\nexport function isValidNodeName(nodeName) {\n  return VALID_NODE_NAMES.includes(nodeName)\n}\n/*\n * For Head, we only care about element nodes(type = 1), so this util is used to skip over non-element nodes\n * For Node type, see https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n */\nexport function isElementType(node) {\n  return node.nodeType === 1\n}\n\n/**\n * Removes all the head elements that were added by `Head`\n */\nexport function removePrevHeadElements() {\n  const prevHeadNodes = document.querySelectorAll(`[data-gatsby-head]`)\n  for (const node of prevHeadNodes) {\n    node.parentNode.removeChild(node)\n  }\n}\n\nexport function applyHtmlAndBodyAttributes(htmlAndBodyAttributes) {\n  if (!htmlAndBodyAttributes) return\n\n  const { html, body } = htmlAndBodyAttributes\n\n  const htmlElement = document.querySelector(`html`)\n  if (htmlElement) {\n    Object.entries(html).forEach(([attributeName, attributeValue]) => {\n      htmlElement.setAttribute(attributeName, attributeValue)\n    })\n  }\n\n  const bodyElement = document.querySelector(`body`)\n  if (bodyElement) {\n    Object.entries(body).forEach(([attributeName, attributeValue]) => {\n      bodyElement.setAttribute(attributeName, attributeValue)\n    })\n  }\n}\n\nexport function removeHtmlAndBodyAttributes(htmlAndBodyattributeList) {\n  if (!htmlAndBodyattributeList) return\n\n  const { html, body } = htmlAndBodyattributeList\n\n  if (html) {\n    const htmlElement = document.querySelector(`html`)\n    html.forEach(attributeName => {\n      if (htmlElement) {\n        htmlElement.removeAttribute(attributeName)\n      }\n    })\n  }\n\n  if (body) {\n    const bodyElement = document.querySelector(`body`)\n    body.forEach(attributeName => {\n      if (bodyElement) {\n        bodyElement.removeAttribute(attributeName)\n      }\n    })\n  }\n}\n"],"mappings":"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"}