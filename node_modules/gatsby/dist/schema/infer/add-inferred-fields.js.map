{"version":3,"file":"add-inferred-fields.js","names":["_","require","ObjectTypeComposer","GraphQLList","invariant","report","getDataStore","addInferredFields","schemaComposer","typeComposer","exampleValue","typeMapping","config","getInferenceConfig","defaults","shouldAddFields","addInferredFieldsImpl","exampleObject","prefix","getTypeName","unsanitizedFieldPath","deprecatedNodeKeys","size","plugin","getExtension","reportOnce","module","exports","fields","Object","keys","forEach","unsanitizedKey","key","createFieldName","push","fieldsByKey","groupBy","field","possibleFields","selectedField","length","resolveMultipleFields","possibleFieldsNames","map","join","warn","fieldConfig","getFieldConfig","hasField","addFields","setFieldExtension","Set","selector","arrays","value","Array","isArray","hasMapping","getFieldConfigFromMapping","includes","getFieldConfigFromFieldNameConvention","multiple","add","getSimpleFieldConfig","pop","split","extensions","proxy","from","type","nodeField","find","canonicalField","sortBy","mapping","path","link","by","foreignKey","replace","linkedTypesSet","linkedValues","linkedNodes","iterateNodes","node","get","has","internal","id","getNode","linkedTypes","typeName","sort","getOrCreateUTC","utc","setTypes","getOTC","setResolveType","is32BitInteger","isDate","dateformat","isFile","fileByRelativePath","Date","String","fieldTypeComposer","getFieldTC","lists","fieldType","getFieldType","ofType","createTypeName","create","setExtension","addDerivedType","derivedTypeName","inferenceConfig","Error","suffix","slice","upperFirst","NON_ALPHA_NUMERIC_EXPR","RegExp","fieldName","replaced","match","char","index","hasExtension"],"sources":["../../../src/schema/infer/add-inferred-fields.js"],"sourcesContent":["const _ = require(`lodash`)\nconst { ObjectTypeComposer } = require(`graphql-compose`)\nconst { GraphQLList } = require(`graphql`)\nconst invariant = require(`invariant`)\nconst report = require(`gatsby-cli/lib/reporter`)\n\nimport { isFile } from \"./is-file\"\nimport { isDate } from \"../types/date\"\nimport { addDerivedType } from \"../types/derived-types\"\nimport { reportOnce } from \"../../utils/report-once\"\nimport { is32BitInteger } from \"../../utils/is-32-bit-integer\"\nconst { getDataStore } = require(`../../datastore`)\n\nconst addInferredFields = ({\n  schemaComposer,\n  typeComposer,\n  exampleValue,\n  typeMapping,\n}) => {\n  const config = getInferenceConfig({\n    typeComposer,\n    defaults: {\n      shouldAddFields: true,\n    },\n  })\n  addInferredFieldsImpl({\n    schemaComposer,\n    typeComposer,\n    exampleObject: exampleValue,\n    prefix: typeComposer.getTypeName(),\n    unsanitizedFieldPath: [typeComposer.getTypeName()],\n    typeMapping,\n    config,\n  })\n\n  if (deprecatedNodeKeys.size > 0) {\n    const plugin = typeComposer.getExtension(`plugin`)\n\n    reportOnce(\n      `Plugin \"${plugin}\" is using the ___NODE convention which is deprecated. This plugin should use the @link directive instead.\\nMigration: https://gatsby.dev/node-convention-deprecation`,\n      `verbose`\n    )\n  }\n}\n\nmodule.exports = {\n  addInferredFields,\n}\n\nconst addInferredFieldsImpl = ({\n  schemaComposer,\n  typeComposer,\n  exampleObject,\n  typeMapping,\n  prefix,\n  unsanitizedFieldPath,\n  config,\n}) => {\n  const fields = []\n  Object.keys(exampleObject).forEach(unsanitizedKey => {\n    const key = createFieldName(unsanitizedKey)\n    fields.push({\n      key,\n      unsanitizedKey,\n      exampleValue: exampleObject[unsanitizedKey],\n    })\n  })\n\n  const fieldsByKey = _.groupBy(fields, field => field.key)\n\n  Object.keys(fieldsByKey).forEach(key => {\n    const possibleFields = fieldsByKey[key]\n    let selectedField\n    if (possibleFields.length > 1) {\n      const field = resolveMultipleFields(possibleFields)\n      const possibleFieldsNames = possibleFields\n        .map(field => `\\`${field.unsanitizedKey}\\``)\n        .join(`, `)\n      report.warn(\n        `Multiple node fields resolve to the same GraphQL field \\`${prefix}.${field.key}\\` - [${possibleFieldsNames}]. Gatsby will use \\`${field.unsanitizedKey}\\`.`\n      )\n      selectedField = field\n    } else {\n      selectedField = possibleFields[0]\n    }\n\n    const fieldConfig = getFieldConfig({\n      ...selectedField,\n      schemaComposer,\n      typeComposer,\n      prefix,\n      unsanitizedFieldPath,\n      typeMapping,\n      config,\n    })\n\n    if (!fieldConfig) return\n\n    if (!typeComposer.hasField(key)) {\n      if (config.shouldAddFields) {\n        typeComposer.addFields({ [key]: fieldConfig })\n        typeComposer.setFieldExtension(key, `createdFrom`, `inference`)\n      }\n    }\n  })\n\n  return typeComposer\n}\n\nconst deprecatedNodeKeys = new Set()\n\nconst getFieldConfig = ({\n  schemaComposer,\n  typeComposer,\n  prefix,\n  exampleValue,\n  key,\n  unsanitizedKey,\n  unsanitizedFieldPath,\n  typeMapping,\n  config,\n}) => {\n  const selector = `${prefix}.${key}`\n  unsanitizedFieldPath.push(unsanitizedKey)\n\n  let arrays = 0\n  let value = exampleValue\n  while (Array.isArray(value)) {\n    value = value[0]\n    arrays++\n  }\n\n  let fieldConfig\n  if (hasMapping(typeMapping, selector)) {\n    // TODO: Use `prefix` instead of `selector` in hasMapping and getFromMapping?\n    // i.e. does the config contain sanitized field names?\n    fieldConfig = getFieldConfigFromMapping({ typeMapping, selector })\n  } else if (unsanitizedKey.includes(`___NODE`)) {\n    // TODO(v5): Remove ability to use foreign keys like this (e.g. author___NODE___contact___email)\n    // and recommend using schema customization instead\n\n    fieldConfig = getFieldConfigFromFieldNameConvention({\n      schemaComposer,\n      value: exampleValue,\n      key: unsanitizedKey,\n    })\n    arrays = arrays + (value.multiple ? 1 : 0)\n\n    deprecatedNodeKeys.add(unsanitizedKey)\n  } else {\n    fieldConfig = getSimpleFieldConfig({\n      schemaComposer,\n      typeComposer,\n      key,\n      value,\n      selector,\n      unsanitizedFieldPath,\n      typeMapping,\n      config,\n      arrays,\n    })\n  }\n\n  unsanitizedFieldPath.pop()\n  if (!fieldConfig) return null\n\n  // Proxy resolver to unsanitized fieldName in case it contained invalid characters\n  if (key !== unsanitizedKey.split(`___NODE`)[0]) {\n    fieldConfig = {\n      ...fieldConfig,\n      extensions: {\n        ...(fieldConfig.extensions || {}),\n        proxy: { from: unsanitizedKey },\n      },\n    }\n  }\n\n  while (arrays > 0) {\n    fieldConfig = { ...fieldConfig, type: [fieldConfig.type] }\n    arrays--\n  }\n\n  return fieldConfig\n}\n\nconst resolveMultipleFields = possibleFields => {\n  const nodeField = possibleFields.find(field =>\n    field.unsanitizedKey.includes(`___NODE`)\n  )\n  if (nodeField) {\n    return nodeField\n  }\n\n  const canonicalField = possibleFields.find(\n    field => field.unsanitizedKey === field.key\n  )\n  if (canonicalField) {\n    return canonicalField\n  }\n\n  return _.sortBy(possibleFields, field => field.unsanitizedKey)[0]\n}\n\n// XXX(freiksenet): removing this as it's a breaking change\n// Deeper nested levels should be inferred as JSON.\n// const MAX_DEPTH = 5\n\nconst hasMapping = (mapping, selector) =>\n  mapping && Object.keys(mapping).includes(selector)\n\nconst getFieldConfigFromMapping = ({ typeMapping, selector }) => {\n  const [type, ...path] = typeMapping[selector].split(`.`)\n  return {\n    type,\n    extensions: {\n      link: { by: path.join(`.`) || `id` },\n    },\n  }\n}\n\n// probably should be in example value\nconst getFieldConfigFromFieldNameConvention = ({\n  schemaComposer,\n  value,\n  key,\n}) => {\n  const path = key.split(`___NODE___`)[1]\n  // Allow linking by nested fields, e.g. `author___NODE___contact___email`\n  const foreignKey = path && path.replace(/___/g, `.`)\n  const linkedTypesSet = new Set()\n\n  if (foreignKey) {\n    const linkedValues = new Set(value.linkedNodes)\n    getDataStore()\n      .iterateNodes()\n      .forEach(node => {\n        const value = _.get(node, foreignKey)\n        if (linkedValues.has(value)) {\n          linkedTypesSet.add(node.internal.type)\n        }\n      })\n  } else {\n    value.linkedNodes.forEach(id => {\n      const node = getDataStore().getNode(id)\n      if (node) {\n        linkedTypesSet.add(node.internal.type)\n      }\n    })\n  }\n\n  const linkedTypes = [...linkedTypesSet]\n\n  invariant(\n    linkedTypes.length,\n    `Encountered an error trying to infer a GraphQL type for: \\`${key}\\`. ` +\n      `There is no corresponding node with the \\`id\\` field matching: \"${value.linkedNodes}\".`\n  )\n\n  let type\n  // If the field value is an array that links to more than one type,\n  // create a GraphQLUnionType. Note that we don't support the case where\n  // scalar fields link to different types. Similarly, an array of objects\n  // with foreign-key fields will produce union types if those foreign-key\n  // fields are arrays, but not if they are scalars. See the tests for an example.\n  if (linkedTypes.length > 1) {\n    const typeName = linkedTypes.sort().join(``) + `Union`\n    type = schemaComposer.getOrCreateUTC(typeName, utc => {\n      utc.setTypes(linkedTypes.map(typeName => schemaComposer.getOTC(typeName)))\n      utc.setResolveType(node => node.internal.type)\n    })\n  } else {\n    type = linkedTypes[0]\n  }\n\n  return {\n    type,\n    extensions: {\n      link: { by: foreignKey || `id`, from: key },\n    },\n  }\n}\n\nconst getSimpleFieldConfig = ({\n  schemaComposer,\n  typeComposer,\n  key,\n  value,\n  selector,\n  unsanitizedFieldPath,\n  typeMapping,\n  config,\n  arrays,\n}) => {\n  switch (typeof value) {\n    case `boolean`:\n      return { type: `Boolean` }\n    case `number`:\n      return { type: is32BitInteger(value) ? `Int` : `Float` }\n    case `string`:\n      if (isDate(value)) {\n        return { type: `Date`, extensions: { dateformat: {} } }\n      }\n      if (isFile(unsanitizedFieldPath, value)) {\n        // NOTE: For arrays of files, where not every path references\n        // a File node in the db, it is semi-random if the field is\n        // inferred as File or String, since the exampleValue only has\n        // the first entry (which could point to an existing file or not).\n        return { type: `File`, extensions: { fileByRelativePath: {} } }\n      }\n      return { type: `String` }\n    case `object`:\n      if (value instanceof Date) {\n        return { type: `Date`, extensions: { dateformat: {} } }\n      }\n      if (value instanceof String) {\n        return { type: `String` }\n      }\n      if (value /* && depth < MAX_DEPTH*/) {\n        let fieldTypeComposer\n        if (typeComposer.hasField(key)) {\n          fieldTypeComposer = typeComposer.getFieldTC(key)\n          // If we have an object as a field value, but the field type is\n          // explicitly defined as something other than an ObjectType\n          // we can bail early.\n          if (!(fieldTypeComposer instanceof ObjectTypeComposer)) return null\n          // If the array depth of the field value and of the explicitly\n          // defined field type don't match we can also bail early.\n          let lists = 0\n          let fieldType = typeComposer.getFieldType(key)\n          while (fieldType.ofType) {\n            if (fieldType instanceof GraphQLList) lists++\n            fieldType = fieldType.ofType\n          }\n          if (lists !== arrays) return null\n        } else {\n          // When the field type has not been explicitly defined, we\n          // don't need to continue in case of @dontInfer\n          if (!config.shouldAddFields) return null\n\n          const typeName = createTypeName(selector)\n          if (schemaComposer.has(typeName)) {\n            // Type could have been already created via schema customization\n            fieldTypeComposer = schemaComposer.getOTC(typeName)\n          } else {\n            fieldTypeComposer = ObjectTypeComposer.create(\n              typeName,\n              schemaComposer\n            )\n            fieldTypeComposer.setExtension(`createdFrom`, `inference`)\n            fieldTypeComposer.setExtension(\n              `plugin`,\n              typeComposer.getExtension(`plugin`)\n            )\n            addDerivedType({\n              typeComposer,\n              derivedTypeName: fieldTypeComposer.getTypeName(),\n            })\n          }\n        }\n\n        // Inference config options are either explicitly defined on a type\n        // with directive/extension, or inherited from the parent type.\n        const inferenceConfig = getInferenceConfig({\n          typeComposer: fieldTypeComposer,\n          defaults: config,\n        })\n\n        return {\n          type: addInferredFieldsImpl({\n            schemaComposer,\n            typeComposer: fieldTypeComposer,\n            exampleObject: value,\n            typeMapping,\n            prefix: selector,\n            unsanitizedFieldPath,\n            config: inferenceConfig,\n          }),\n        }\n      }\n  }\n  throw new Error(`Can't determine type for \"${value}\" in \\`${selector}\\`.`)\n}\n\nconst createTypeName = selector => {\n  const keys = selector.split(`.`)\n  const suffix = keys.slice(1).map(_.upperFirst).join(``)\n  return `${keys[0]}${suffix}`\n}\n\nconst NON_ALPHA_NUMERIC_EXPR = new RegExp(`[^a-zA-Z0-9_]`, `g`)\n\n/**\n * GraphQL field names must be a string and cannot contain anything other than\n * alphanumeric characters and `_`. They also can't start with `__` which is\n * reserved for internal fields (`___foo` doesn't work either).\n */\nconst createFieldName = key => {\n  // Check if the key is really a string otherwise GraphQL will throw.\n  invariant(\n    typeof key === `string`,\n    `GraphQL field name (key) is not a string: \\`${key}\\`.`\n  )\n\n  const fieldName = key.split(`___NODE`)[0]\n  const replaced = fieldName.replace(NON_ALPHA_NUMERIC_EXPR, `_`)\n\n  // key is invalid; normalize with leading underscore and rest with x\n  if (replaced.match(/^__/)) {\n    return replaced.replace(/_/g, (char, index) => (index === 0 ? `_` : `x`))\n  }\n\n  // key is invalid (starts with numeric); normalize with leading underscore\n  if (replaced.match(/^[0-9]/)) {\n    return `_` + replaced\n  }\n\n  return replaced\n}\n\nconst getInferenceConfig = ({ typeComposer, defaults }) => {\n  return {\n    shouldAddFields: typeComposer.hasExtension(`infer`)\n      ? typeComposer.getExtension(`infer`)\n      : defaults.shouldAddFields,\n  }\n}\n"],"mappings":"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"}