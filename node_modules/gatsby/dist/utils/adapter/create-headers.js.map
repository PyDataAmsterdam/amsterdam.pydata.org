{"version":3,"file":"create-headers.js","names":["normalizePath","input","endsWith","createHeadersMatcher","headers","dynamicHeaders","staticHeaders","Map","length","_path","defaultHeaders","header","source","includes","score","rankRoute","push","set","sort","a","b","order","localeCompare","path","uniqueHeaders","h","key","value","d","match","staticEntry","get","Array","from","entries","map"],"sources":["../../../src/utils/adapter/create-headers.ts"],"sourcesContent":["import { match } from \"@gatsbyjs/reach-router\"\nimport type { IHeader } from \"../../redux/types\"\nimport { rankRoute } from \"../rank-route\"\n\ntype Headers = IHeader[\"headers\"]\ninterface IHeaderWithScore extends IHeader {\n  score: number\n}\n\n// We don't care if the path has a trailing slash or not, but to be able to compare stuff we need to normalize it\nconst normalizePath = (input: string): string =>\n  input.endsWith(`/`) ? input : `${input}/`\n\nexport const createHeadersMatcher = (\n  headers: Array<IHeader> | undefined\n): ((path: string, defaultHeaders: Headers) => Headers) => {\n  // Split the incoming user headers into two buckets:\n  // - dynamicHeaders: Headers with dynamic paths (e.g. /* or /:tests)\n  // - staticHeaders: Headers with fully static paths (e.g. /static/)\n  // Also add a score using the rankRoute function to each header\n  let dynamicHeaders: Array<IHeaderWithScore> = []\n  const staticHeaders: Map<string, IHeader> = new Map()\n\n  // If no custom headers are defined by the user in the gatsby-config, we can return only the default headers\n  if (!headers || headers.length === 0) {\n    return (_path: string, defaultHeaders: Headers) => defaultHeaders\n  }\n\n  for (const header of headers) {\n    if (header.source.includes(`:`) || header.source.includes(`*`)) {\n      // rankRoute is the internal function that also \"match\" uses\n      const score = rankRoute(header.source)\n\n      dynamicHeaders.push({ ...header, score })\n    } else {\n      staticHeaders.set(normalizePath(header.source), header)\n    }\n  }\n\n  // Sort the dynamic headers by score, moving the ones with the highest specificity to the end of the array\n  // If the score is the same, do a lexigraphic comparison of the source\n  dynamicHeaders = dynamicHeaders.sort((a, b) => {\n    const order = a.score - b.score\n    if (order !== 0) {\n      return order\n    }\n    return a.source.localeCompare(b.source)\n  })\n\n  return (path: string, defaultHeaders: Headers): Headers => {\n    // Create a map of headers for the given path\n    // The key will be the header key. Since a key may only appear once in a map, the last header with the same key will win\n    const uniqueHeaders: Map<string, string> = new Map()\n\n    // 1. Add default headers\n    for (const h of defaultHeaders) {\n      uniqueHeaders.set(h.key, h.value)\n    }\n\n    // 2. Add dynamic headers that match the current path\n    for (const d of dynamicHeaders) {\n      if (match(d.source, path)) {\n        for (const h of d.headers) {\n          uniqueHeaders.set(h.key, h.value)\n        }\n      }\n    }\n\n    const staticEntry = staticHeaders.get(normalizePath(path))\n\n    // 3. Add static headers that match the current path\n    if (staticEntry) {\n      for (const h of staticEntry.headers) {\n        uniqueHeaders.set(h.key, h.value)\n      }\n    }\n\n    // Convert the map back to an array of objects\n    return Array.from(uniqueHeaders.entries()).map(([key, value]) => {\n      return {\n        key,\n        value,\n      }\n    })\n  }\n}\n"],"mappings":";;;;AAAA;AAEA;AAOA;AACA,MAAMA,aAAa,GAAIC,KAAa,IAClCA,KAAK,CAACC,QAAQ,CAAE,GAAE,CAAC,GAAGD,KAAK,GAAI,GAAEA,KAAM,GAAE;AAEpC,MAAME,oBAAoB,GAC/BC,OAAmC,IACsB;EACzD;EACA;EACA;EACA;EACA,IAAIC,cAAuC,GAAG,EAAE;EAChD,MAAMC,aAAmC,GAAG,IAAIC,GAAG,EAAE;;EAErD;EACA,IAAI,CAACH,OAAO,IAAIA,OAAO,CAACI,MAAM,KAAK,CAAC,EAAE;IACpC,OAAO,CAACC,KAAa,EAAEC,cAAuB,KAAKA,cAAc;EACnE;EAEA,KAAK,MAAMC,MAAM,IAAIP,OAAO,EAAE;IAC5B,IAAIO,MAAM,CAACC,MAAM,CAACC,QAAQ,CAAE,GAAE,CAAC,IAAIF,MAAM,CAACC,MAAM,CAACC,QAAQ,CAAE,GAAE,CAAC,EAAE;MAC9D;MACA,MAAMC,KAAK,GAAG,IAAAC,oBAAS,EAACJ,MAAM,CAACC,MAAM,CAAC;MAEtCP,cAAc,CAACW,IAAI,CAAC;QAAE,GAAGL,MAAM;QAAEG;MAAM,CAAC,CAAC;IAC3C,CAAC,MAAM;MACLR,aAAa,CAACW,GAAG,CAACjB,aAAa,CAACW,MAAM,CAACC,MAAM,CAAC,EAAED,MAAM,CAAC;IACzD;EACF;;EAEA;EACA;EACAN,cAAc,GAAGA,cAAc,CAACa,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;IAC7C,MAAMC,KAAK,GAAGF,CAAC,CAACL,KAAK,GAAGM,CAAC,CAACN,KAAK;IAC/B,IAAIO,KAAK,KAAK,CAAC,EAAE;MACf,OAAOA,KAAK;IACd;IACA,OAAOF,CAAC,CAACP,MAAM,CAACU,aAAa,CAACF,CAAC,CAACR,MAAM,CAAC;EACzC,CAAC,CAAC;EAEF,OAAO,CAACW,IAAY,EAAEb,cAAuB,KAAc;IACzD;IACA;IACA,MAAMc,aAAkC,GAAG,IAAIjB,GAAG,EAAE;;IAEpD;IACA,KAAK,MAAMkB,CAAC,IAAIf,cAAc,EAAE;MAC9Bc,aAAa,CAACP,GAAG,CAACQ,CAAC,CAACC,GAAG,EAAED,CAAC,CAACE,KAAK,CAAC;IACnC;;IAEA;IACA,KAAK,MAAMC,CAAC,IAAIvB,cAAc,EAAE;MAC9B,IAAI,IAAAwB,kBAAK,EAACD,CAAC,CAAChB,MAAM,EAAEW,IAAI,CAAC,EAAE;QACzB,KAAK,MAAME,CAAC,IAAIG,CAAC,CAACxB,OAAO,EAAE;UACzBoB,aAAa,CAACP,GAAG,CAACQ,CAAC,CAACC,GAAG,EAAED,CAAC,CAACE,KAAK,CAAC;QACnC;MACF;IACF;IAEA,MAAMG,WAAW,GAAGxB,aAAa,CAACyB,GAAG,CAAC/B,aAAa,CAACuB,IAAI,CAAC,CAAC;;IAE1D;IACA,IAAIO,WAAW,EAAE;MACf,KAAK,MAAML,CAAC,IAAIK,WAAW,CAAC1B,OAAO,EAAE;QACnCoB,aAAa,CAACP,GAAG,CAACQ,CAAC,CAACC,GAAG,EAAED,CAAC,CAACE,KAAK,CAAC;MACnC;IACF;;IAEA;IACA,OAAOK,KAAK,CAACC,IAAI,CAACT,aAAa,CAACU,OAAO,EAAE,CAAC,CAACC,GAAG,CAAC,CAAC,CAACT,GAAG,EAAEC,KAAK,CAAC,KAAK;MAC/D,OAAO;QACLD,GAAG;QACHC;MACF,CAAC;IACH,CAAC,CAAC;EACJ,CAAC;AACH,CAAC;AAAA"}