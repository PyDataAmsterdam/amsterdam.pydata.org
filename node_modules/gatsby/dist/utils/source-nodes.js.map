{"version":3,"file":"source-nodes.js","names":["deleteNode","actions","discoverPluginNamesWithoutNodes","typeOwners","flattenedPlugins","store","getState","pluginNamesThatCreatedNodes","Set","Array","from","pluginsToTypes","keys","filter","plugin","nodeAPIs","includes","has","name","map","warnForPluginsWithoutNodes","pluginNamesWithNoNodes","report","warn","getStaleNodes","state","nodes","node","rootNode","next","undefined","whileCount","parent","getNode","console","log","statefulSourcePlugins","internal","owner","nodesTouched","id","deleteStaleNodes","previouslyExistingNodeTypeNames","deleteCount","cleanupStaleNodesActivity","createProgress","start","typeName","pluginName","typesToPlugins","get","verbose","getDataStore","iterateNodesByType","staleNodes","dispatch","tick","Promise","res","setImmediate","end","is","initialSourceNodesOfCurrentNodeProcess","sourcingCount","webhookBody","parentSpan","deferNodeMutation","traceId","sourceNodesApiRunner","ready","length","apiFinished","apiName"],"sources":["../../src/utils/source-nodes.ts"],"sourcesContent":["import report from \"gatsby-cli/lib/reporter\"\nimport { Span } from \"opentracing\"\nimport { sourceNodesApiRunner } from \"./source-nodes-api-runner\"\nimport { store } from \"../redux\"\nimport { getDataStore, getNode } from \"../datastore\"\nimport { actions } from \"../redux/actions\"\nimport { IGatsbyState, IGatsbyNode } from \"../redux/types\"\nimport type { GatsbyIterable } from \"../datastore/common/iterable\"\n\nconst { deleteNode } = actions\n\n/**\n * Finds the name of all plugins which implement Gatsby APIs that\n * may create nodes, but which have not actually created any nodes.\n */\nfunction discoverPluginNamesWithoutNodes(): Array<string> {\n  const { typeOwners, flattenedPlugins } = store.getState()\n\n  // Find out which plugins own already created nodes\n  const pluginNamesThatCreatedNodes = new Set([\n    `default-site-plugin`,\n    // each plugin that owns node types created a node at some point\n    ...Array.from(typeOwners.pluginsToTypes.keys()),\n  ])\n\n  return flattenedPlugins\n    .filter(\n      plugin =>\n        // \"Can generate nodes\"\n        plugin.nodeAPIs.includes(`sourceNodes`) &&\n        // \"Has not generated nodes\"\n        !pluginNamesThatCreatedNodes.has(plugin.name)\n    )\n    .map(plugin => plugin.name)\n}\n\n/**\n * Warn about plugins that should have created nodes but didn't.\n */\nfunction warnForPluginsWithoutNodes(): void {\n  const pluginNamesWithNoNodes = discoverPluginNamesWithoutNodes()\n\n  pluginNamesWithNoNodes.map(name =>\n    report.warn(\n      `The ${name} plugin has generated no Gatsby nodes. Do you need it? This could also suggest the plugin is misconfigured.`\n    )\n  )\n}\n\n/**\n * Return the set of nodes for which its root node has not been touched\n */\nfunction getStaleNodes(\n  state: IGatsbyState,\n  nodes: GatsbyIterable<IGatsbyNode>\n): GatsbyIterable<IGatsbyNode> {\n  return nodes.filter(node => {\n    let rootNode = node\n    let next: IGatsbyNode | undefined = undefined\n\n    let whileCount = 0\n    do {\n      next = rootNode.parent ? getNode(rootNode.parent) : undefined\n      if (next) {\n        rootNode = next\n      }\n    } while (next && ++whileCount < 101)\n\n    if (whileCount > 100) {\n      console.log(\n        `It looks like you have a node that's set its parent as itself`,\n        rootNode\n      )\n    }\n\n    if (state.statefulSourcePlugins.has(rootNode.internal.owner)) {\n      return false\n    }\n\n    return !state.nodesTouched.has(rootNode.id)\n  })\n}\n\n/**\n * Find all stale nodes and delete them unless the node type has been opted out of stale node garbage collection.\n */\nasync function deleteStaleNodes(\n  previouslyExistingNodeTypeNames: Array<string>\n): Promise<void> {\n  const state = store.getState()\n\n  let deleteCount = 0\n\n  const cleanupStaleNodesActivity =\n    report.createProgress(`Clean up stale nodes`)\n\n  cleanupStaleNodesActivity.start()\n\n  const { typeOwners, statefulSourcePlugins } = state\n\n  for (const typeName of previouslyExistingNodeTypeNames) {\n    const pluginName = typeOwners.typesToPlugins.get(typeName)\n\n    // no need to check this type if its owner has declared its a stateful source plugin\n    if (pluginName && statefulSourcePlugins.has(pluginName)) {\n      continue\n    }\n\n    report.verbose(`Checking for stale ${typeName} nodes`)\n\n    const nodes = getDataStore().iterateNodesByType(typeName)\n    const staleNodes = getStaleNodes(state, nodes)\n\n    for (const node of staleNodes) {\n      store.dispatch(deleteNode(node))\n      cleanupStaleNodesActivity.tick()\n\n      if (++deleteCount % 5000) {\n        // dont block event loop\n        await new Promise(res => {\n          setImmediate(() => {\n            res(null)\n          })\n        })\n      }\n    }\n  }\n\n  cleanupStaleNodesActivity.end()\n}\n\n// exported for unit tests purposes only to allow internal module state resets\nexport const is = {\n  initialSourceNodesOfCurrentNodeProcess: true,\n}\n\nlet sourcingCount = 0\nexport default async ({\n  webhookBody,\n  pluginName,\n  parentSpan,\n  deferNodeMutation = false,\n}: {\n  webhookBody: unknown\n  pluginName?: string\n  parentSpan?: Span\n  deferNodeMutation?: boolean\n}): Promise<void> => {\n  const traceId = is.initialSourceNodesOfCurrentNodeProcess\n    ? `initial-sourceNodes`\n    : `sourceNodes #${sourcingCount}`\n\n  // this is persisted to cache between builds, so it will always have an up to date list of previously created types by plugin name\n  const { typeOwners } = store.getState()\n\n  const previouslyExistingNodeTypeNames: Array<string> = Array.from(\n    typeOwners.typesToPlugins.keys() || []\n  )\n\n  await sourceNodesApiRunner({\n    traceId,\n    deferNodeMutation,\n    parentSpan,\n    webhookBody,\n    pluginName,\n  })\n\n  await getDataStore().ready()\n\n  // We only warn for plugins w/o nodes and delete stale nodes on the first sourceNodes call of the current process.\n  if (is.initialSourceNodesOfCurrentNodeProcess) {\n    is.initialSourceNodesOfCurrentNodeProcess = false\n\n    warnForPluginsWithoutNodes()\n\n    if (\n      // if this is the very first source and no types existed before this sourceNodes run, there's no need to check for stale nodes. They wont be stale because they were just created. Only check for stale nodes in node types that never existed before.\n      previouslyExistingNodeTypeNames.length > 0\n    ) {\n      await deleteStaleNodes(previouslyExistingNodeTypeNames)\n    }\n  }\n\n  store.dispatch(actions.apiFinished({ apiName: `sourceNodes` }))\n\n  sourcingCount += 1\n}\n"],"mappings":"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"}