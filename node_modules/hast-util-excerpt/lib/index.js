/**
 * @typedef {import('hast').Root} Root
 * @typedef {import('hast').Content} Content
 */

/**
 * @typedef {Root | Content} Node
 *
 * @typedef Options
 *   Configuration.
 * @property {string | null | undefined} [comment='more']
 *   Comment value to search for.
 * @property {number | null | undefined} [maxSearchSize=2048]
 *   How far to search for the comment before bailing.
 *   The goal of this project is to find user-defined explicit excerpts, that
 *   are assumed to be somewhat reasonably placed.
 *   This option prevents searching giant documents for some comment
 *   that probably wonâ€™t be found at the end.
 * @property {Array<Content> | null | undefined} [ignore=[]]
 *   Nodes to exclude from the resulting tree.
 *   These are not counted towards `size`.
 */

import {truncate} from 'hast-util-truncate'

/**
 * Truncate `tree` to a certain comment.
 *
 * @template {Node} Tree
 *   Type of tree.
 * @param {Tree} tree
 *   Tree to truncate.
 * @param {Options | null | undefined} [options]
 *   Configuration (optional)
 * @returns {Tree | undefined}
 *   Truncated copy of `tree` when a comment is found, `undefined` otherwise.
 */
export function excerpt(tree, options) {
  const config = options || {}
  const comment = config.comment || 'more'
  const maxSearchSize =
    typeof config.maxSearchSize === 'number' ? config.maxSearchSize : 2048
  let found = false
  const result = preorder(
    truncate(tree, {ignore: config.ignore, size: maxSearchSize})
  )

  // @ts-expect-error: `result` is most likely a clone of `tree`
  return found ? result : undefined

  /**
   * Truncate `node`.
   *
   * @param {Node} node
   *   Node to truncate.
   * @returns {Node | undefined}
   *   Copy of `node` or `undefined` when done.
   */
  function preorder(node) {
    if (node.type === 'comment' && node.value.trim() === comment) {
      found = true
      return
    }

    // Support MDX.
    if (
      (node.type === 'mdxFlowExpression' ||
        node.type === 'mdxTextExpression') &&
      node.data &&
      node.data.estree &&
      node.data.estree.comments &&
      node.data.estree.comments.some((node) => node.value.trim() === comment)
    ) {
      found = true
      return
    }

    /** @type {Node} */
    const replacement = {...node}

    if ('children' in node) {
      /** @type {Array<Content>} */
      const children = []
      let index = -1

      while (++index < node.children.length && !found) {
        const child = node.children[index]
        // @ts-expect-error: children in JSX are transformed to `hast`.
        const result = preorder(child)
        // @ts-expect-error: assume content model matches.
        if (result) children.push(result)
      }

      // @ts-expect-error: assume content model matches.
      replacement.children = children
    }

    return replacement
  }
}
